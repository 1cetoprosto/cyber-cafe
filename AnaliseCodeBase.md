# Аналіз iOS кодової бази: TrackMyCafe

## 📁 Структура проекту

Проект TrackMyCafe має чітку організацію файлів, що відображає модульний підхід до розробки. Основна структура проекту:

```
├── Application/                 # Точка входу в додаток (AppDelegate, SceneDelegate)
├── Configuration/              # Конфігураційні файли для різних середовищ (Dev, Beta, Prod)
├── Data Layer/                 # Шар даних
│   ├── Models/                 # Моделі даних
│   ├── Service/                # Сервіси для роботи з даними
│   └── Utils/                  # Утиліти та допоміжні класи
├── Documentations/             # Документація проекту
├── Entitlements/               # Файли прав доступу
├── Extensions/                 # Розширення стандартних класів
│   └── UI/                     # Розширення UI-компонентів
├── Resources/                  # Ресурси додатку
│   ├── Assets.xcassets/        # Зображення та кольори
│   ├── Icons.xcassets/         # Іконки
│   └── Localization/           # Локалізація (en, uk)
├── Services/                   # Сервіси додатку
│   ├── Domain/                 # Доменні сервіси
│   ├── FIR/                    # Сервіси Firebase
│   └── Realm/                  # Сервіси Realm
├── Utilities/                  # Утиліти
└── View Layer/                 # Шар представлення
    ├── Common/                 # Спільні компоненти
    ├── Flow/                   # Екрани додатку за функціональністю
    └── UI/                     # UI-компоненти
```

Проект організований за принципами MVVM (Model-View-ViewModel) архітектури, де чітко розділені шари даних, бізнес-логіки та представлення. Кожен функціональний модуль (Orders, Costs, Settings тощо) має свою папку з відповідними View та ViewModel компонентами.

## 🛠 Технологічний стек

| Технологія/Інструмент | Версія/Опис |
|----------------------|-------------|
| Swift                | 5.x |
| Мінімальна iOS target | 15.0 |
| UI-фреймворк         | UIKit (програмний підхід без Storyboard) |
| Управління залежностями | CocoaPods + Swift Package Manager |
| Бази даних           | Realm, Firebase Firestore |
| Аутентифікація       | Firebase Auth, Біометрична аутентифікація |
| Локалізація          | Вбудована система локалізації (en, uk) |
| Мережеві запити      | Власна реалізація RequestManager |
| Безпека              | KeychainAccess |
| UI-компоненти        | SVProgressHUD, SwiftEntryKit, TinyConstraints |
| Інші бібліотеки      | AnimatedTextInput, R.swift, TPInAppReceipt, SwiftyStoreKit |

Проект використовує як CocoaPods, так і Swift Package Manager для управління залежностями. Основні залежності включають Firebase для бекенду, Realm для локального зберігання даних, та різні UI-бібліотеки для покращення користувацького інтерфейсу.

## 🏗 Архітектура

Додаток побудований на основі архітектури MVVM (Model-View-ViewModel), що забезпечує чітке розділення відповідальності між компонентами:

- **Model**: Представлений класами в папці `Data Layer/Models`, які відповідають за структуру даних.
- **View**: Реалізований через UIViewController підкласи в папці `View Layer/Flow`.
- **ViewModel**: Містить бізнес-логіку та логіку представлення в папці `View Layer/Flow/*/ViewModel`.

Кожен ViewModel має відповідний протокол (наприклад, `OrderListViewModelType`), що дозволяє легко тестувати та замінювати реалізації.

Приклад взаємодії View і ViewModel:

```swift
// View (OrderListViewController.swift)
func fetchOrdersData() {
    viewModel?.getOrders { [weak self] in
        DispatchQueue.main.async {
            self?.tableView.reloadData()
        }
    }
}

// ViewModel (OrderListViewModel.swift)
func getOrders(completion: @escaping () -> Void) {
    DomainDatabaseService.shared.fetchSectionsOfOrders { [weak self] sectionsOrders in
        self?.sectionsOrders = sectionsOrders
        completion()
    }
}
```

Архітектура даних організована в кілька шарів:

1. **Доменний шар** (`DomainDatabaseService`) - абстрагує джерело даних від бізнес-логіки
2. **Сервісний шар** - включає `FirestoreDatabaseService` для онлайн-даних та `RealmDatabaseService` для локального зберігання
3. **Модельний шар** - містить моделі даних для різних сховищ (Realm, Firestore)

Додаток підтримує як онлайн, так і офлайн режими роботи, перемикаючись між Firebase та Realm залежно від налаштувань та доступності мережі.

## 🎨 UI/UX

Інтерфейс додатку побудований програмно (Programmatic UI) без використання Storyboard або XIB-файлів. Основні підходи:

- Використання UIKit з програмним створенням та налаштуванням UI-елементів
- Власна система кольорів через розширення `UIColor`
- Фабричний метод для створення стандартних UI-компонентів (`UIKitFactory`)
- Табличний інтерфейс з використанням `UITableView` для відображення списків

Приклад створення UI-компонента:

```swift
let tableView: UITableView = {
    let tableView = UITableView()
    tableView.register(OrdersTableViewCell.self, forCellReuseIdentifier: OrdersTableViewCell.identifier)
    tableView.backgroundColor = UIColor.Main.background
    tableView.separatorStyle = .none
    tableView.translatesAutoresizingMaskIntoConstraints = false
    return tableView
}()
```

Навігація реалізована через стандартний `UINavigationController` з налаштованим зовнішнім виглядом. Додаток використовує `UITabBarController` як основний контейнер для головних екранів.

Підтримка темної/світлої теми реалізована через власну систему кольорів, але без повної підтримки системних налаштувань темної теми iOS.

## ✅ Якість коду

**Конвенції іменування:**

- Дотримання Swift API Design Guidelines
- Чіткі та описові імена для класів, методів та змінних
- Послідовна структура директорій за функціональністю

**SOLID-принципи:**

- Single Responsibility: Класи мають чітку відповідальність
- Open/Closed: Використання протоколів для розширення функціональності
- Dependency Inversion: Залежності від абстракцій через протоколи

**Документація:**

- Базові коментарі для класів та методів
- Відсутність повної документації в стилі Swift-DocC

**Тестування:**

- Відсутні явні тести в проекті
- Архітектура MVVM сприяє тестуванню, але тести не реалізовані

## 🔧 Ключові модулі

### 1. Аутентифікація

**Призначення:** Забезпечує вхід, реєстрацію та управління користувачами.

```swift
// UserSession.swift
class UserSession {
    static let current = UserSession()
    
    var isAuth: Bool {
        return userEmail != nil && Auth.auth().currentUser != nil
    }
    
    var isAdmin: Bool {
        return role! == .administrator
    }
}
```

Модуль використовує Firebase Auth для аутентифікації та KeychainAccess для безпечного зберігання облікових даних. Також підтримується біометрична аутентифікація.

### 2. Управління замовленнями

**Призначення:** Дозволяє створювати, переглядати та редагувати замовлення.

```swift
// OrderListViewModel.swift
func getOrders(completion: @escaping () -> Void) {
    DomainDatabaseService.shared.fetchSectionsOfOrders { [weak self] sectionsOrders in
        self?.sectionsOrders = sectionsOrders
        completion()
    }
}
```

Модуль взаємодіє з доменним сервісом для отримання даних, які можуть надходити як з Firebase, так і з локальної бази Realm.

### 3. Управління витратами

**Призначення:** Відстеження та аналіз витрат кафе.

Модуль має подібну до замовлень структуру з розділенням на View та ViewModel компоненти, що демонструє послідовність архітектурного підходу в проекті.

### 4. Локалізація

**Призначення:** Забезпечує підтримку кількох мов (англійська, українська).

```swift
// Використання локалізованих рядків
searchController.searchBar.placeholder = R.string.global.search()
```

Проект використовує бібліотеку R.swift для типобезпечного доступу до локалізованих рядків та ресурсів.

### 5. Підписки та покупки

**Призначення:** Реалізує функціональність внутрішніх покупок та підписок.

Модуль використовує SwiftyStoreKit та TPInAppReceipt для роботи з Apple StoreKit та перевірки чеків покупок.

## 📋 Паттерни та best practices

**Використані паттерни проектування:**

1. **Singleton** - для сервісів та менеджерів (UserSession, DomainDatabaseService)
2. **Factory** - для створення UI-компонентів (UIKitFactory)
3. **Protocol-Oriented Programming** - використання протоколів для визначення контрактів (ViewModelType)
4. **Dependency Injection** - передача залежностей через ініціалізатори та властивості
5. **Observer** - для реактивного оновлення UI при зміні даних

**Підходи до асинхронних операцій:**

- Використання замикань (completion handlers) для асинхронних операцій
- Відсутність сучасних підходів як async/await або Combine

**Організація локалізації:**

- Використання стандартної системи локалізації iOS
- Типобезпечний доступ через R.swift
- Підтримка англійської та української мов

**Безпека:**

- Використання KeychainAccess для зберігання чутливих даних
- Біометрична аутентифікація (Face ID / Touch ID)

## 📋 Висновки та рекомендації

### Сильні сторони

- Чітка архітектура MVVM з розділенням відповідальності
- Підтримка онлайн/офлайн режимів роботи
- Модульна організація коду за функціональністю
- Хороша локалізація з підтримкою кількох мов
- Використання сучасних бібліотек та інструментів

### Області для покращення

- Відсутність автоматизованих тестів
- Обмежена документація коду
- Використання застарілих підходів до асинхронності (замість async/await або Combine)
- Відсутність повної підтримки темної теми iOS
- Відсутність SwiftUI компонентів для новіших частин додатку

### Рівень складності проекту

Проект має середній рівень складності (middle-friendly). Він використовує стандартні архітектурні підходи та технології, але вимагає розуміння MVVM, роботи з Firebase та Realm, а також досвіду програмного створення UI.

Для junior-розробників проект може бути складним через відсутність Storyboard та необхідність розуміння багатошарової архітектури. Для senior-розробників проект надає хорошу основу для впровадження сучасніших підходів та покращення існуючої архітектури.

Загалом, TrackMyCafe - це добре структурований додаток для управління кафе з чіткою архітектурою та модульною організацією, який може бути хорошою основою для подальшого розвитку та вдосконалення.
